import datetime

from googlesearch import search
from urllib.error import HTTPError

import pickle
import codecs
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
import dateutil.parser

from google.cloud import texttospeech
from google.cloud.texttospeech import enums

import google.auth.credentials as google_auth_credentials
from google.auth import default as google_auth_default

from google.oauth2 import service_account
import os

from typing import Union

from google.cloud import vision

from .config import DefaultConfig as Config

class Google:
    """
    A Google search function. Eventually a domain kicks you for ~1 hour so we just change domain.
    A problem that may occur is if the program keeps on getting kicked from these
    domains and it enters a kind of infinite loop trying different domains.
    """

    def __init__(self, verbosity=5):
        self.verbosity = verbosity
        # the index of the top level domains to start off with
        self.tld_index = 0
        # top level domains for the google search
        self.tld_array = ["com", "co.in", "co.za", "co.uk", "co.de", "co.id", "ru", "ae", "fr"]

    def search(self, query: str):
        """
        Performs a Google search with the given query and returns the highest ranked link.
        Returns None if it cannot find one or if something went wrong.

        :param query: The string of the query
        :return: The str of the url result
        """

        search_successful = False
        result = None

        # if getting too many requests, change tld to co.in and com, co.za
        while not search_successful:
            if self.tld_index >= len(self.tld_array):
                raise ConnectionRefusedError("We got kicked from too many top level domains. "
                                             "Wait a bit or add more top level domains in tld_array")
            try:
                urls = search(query, tld=self.tld_array[self.tld_index], num=1, stop=1, pause=2,
                              # domains=[""],
                              user_agent="GoogleSearchBotThing/1.0")
                for url in urls:
                    result = url

                search_successful = True
            except HTTPError as error:
                # self.tld_index = (self.tld_index + 1) % len(tld_array)  # cycle through will give infinite loop
                self.tld_index = self.tld_index + 1
                # printer = Printer(self.verbosity)
                # printer.pprint(8, "Too many requests from TLD. Switching to", self.tld_array[self.tld_index], error)
                search_successful = False
                pass
        return result


class CalendarEvent:
    """
    A helper class for the Calendar class.
    https://developers.google.com/calendar/v3/reference/events/instances
    https://developers.google.com/calendar/v3/reference
    https://developers.google.com/calendar/concepts
    """

    event_color_ids = {"light blue": 1,
                       "purpur": 1,
                       "light green": 2,
                       "green": 2,
                       "purple": 3,
                       "pink": 4,
                       "yellow": 5,
                       "orange": 6,
                       "cyan": 7,
                       "grey": 8,
                       "gray": 8,
                       "dark blue": 9,
                       "dark green": 10,
                       "dark red": 11}

    def __init__(self,
                 summary,
                 start,
                 end=None,
                 timezone="Africa/Johannesburg",  # datetime.timedelta(seconds=7200),  # UTC+2
                 event_id=None,
                 description=None,
                 location=None,
                 recurrence=None,
                 color=None,
                 visibility="default",  # `public` or `private`
                 reminders=None,
                 default_reminders=False,
                 minutes_before_popup_reminder=None,
                 minutes_before_email_reminder=None,
                 **other):
        """
        :param summary:
                title of the event.
        :param start:
                starting date/datetime.
        :param end:
                ending date/datetime. If 'end' is not specified, event is considered as a 1-day or 1-hour event
                if 'start' is date or datetime respectively.
        :param timezone:
                timezone formatted as an IANA Time Zone Database name, e.g. "Europe/Zurich". By default,
                the computers configured local timezone(if any) is used.
        :param event_id:
                opaque identifier of the event. By default is generated by the server. You can specify id as a
                5-1024 long string of characters used in base32hex ([a-vA-V0-9]). The ID must be unique per
                calendar.
        :param description:
                description of the event.
        :param location:
                geographic location of the event as free-form text.
        :param recurrence:
                RRULE/RDATE/EXRULE/EXDATE string or list of such strings. See :py:mod:`~gcsa.recurrence`
        :param color:
                color id referring to an entry from colors endpoint (list_event_colors)
        :param visibility:
                visibility of the event. Default is default visibility for events on the calendar.
        :param reminders:
                reminder or list of reminder objects. See :py:mod:`~gcsa.reminders`
        :param default_reminders:
                whether the default reminders of the calendar apply to the event.
        :param minutes_before_popup_reminder:
                minutes before popup reminder or None if reminder is not needed.
        :param minutes_before_email_reminder:
                minutes before email reminder or None if reminder is not needed.
        :param other:
                Other fields that should be included in request json. Will be included as they are.
        """

        def assure_list(obj):
            return obj if isinstance(obj, list) else obj or []

        self.timezone = timezone
        self.start = start
        if end:
            self.end = end
        elif isinstance(start, datetime.datetime):
            self.end = start + datetime.timedelta(hours=1)
        elif isinstance(start, datetime.date):
            self.end = start + datetime.timedelta(days=1)

        reminders = assure_list(reminders)

        if len(reminders) > 5:
            raise ValueError('The maximum number of override reminders is 5.')

        if default_reminders and reminders:
            raise ValueError('Cannot specify both default reminders and overrides at the same time.')

        self.event_id = event_id and event_id.lower()
        self.summary = summary
        self.description = description
        self.location = location
        self.recurrence = assure_list(recurrence)

        try:
            self.color_id = int(color)
        except ValueError:
            self.color_id = self.event_color_ids[color]

        self.visibility = visibility
        self.reminders = reminders
        self.default_reminders = default_reminders
        self.other = other

        if minutes_before_popup_reminder:
            self.add_popup_reminder(minutes_before_popup_reminder)
        if minutes_before_email_reminder:
            self.add_email_reminder(minutes_before_email_reminder)

    def add_email_reminder(self, minutes_before_start=60):
        """Adds email reminder to an event. See :py:class:`~gcsa.reminders.EmailReminder`"""
        self.add_reminder({
            'method': "email",
            'minutes': minutes_before_start
        })  # method: 'email', minutes_before_start

    def add_popup_reminder(self, minutes_before_start=30):
        """Adds popup reminder to an event. See :py:class:`~gcsa.reminders.PopupReminder`"""
        self.add_reminder({
            'method': "popup",
            'minutes': minutes_before_start
        })  # method: 'popup', minutes_before_start

    def add_reminder(self, reminder):
        """Adds reminder to an event. See :py:mod:`~gcsa.reminders`"""
        if len(self.reminders) > 4:
            raise ValueError('The maximum number of override reminders is 5.')
        self.reminders.append(reminder)

    def __str__(self):
        return '{} - {}'.format(self.start, self.summary)

    def to_json(self):

        data = {
            "summary": self.summary,
            "description": self.description,
            "location": self.location,
            "recurrence": self.recurrence,
            "colorId": self.color_id,
            "visibility": self.visibility,
            "reminders": {
                "useDefault": self.default_reminders,
                "overrides": self.reminders
            },
            **self.other
        }

        if isinstance(self.start, datetime.datetime) and isinstance(self.end, datetime.datetime):
            data['start'] = {
                'dateTime': self.start.isoformat(),
                'timeZone': self.timezone
            }
            data['end'] = {
                'dateTime': self.end.isoformat(),
                'timeZone': self.timezone
            }
        elif isinstance(self.start, datetime.date) and isinstance(self.end, datetime.date):
            data['start'] = {'date': self.start.isoformat()}
            data['end'] = {'date': self.end.isoformat()}

        if self.default_reminders:
            data['reminders'] = {
                "useDefault": True
            }
        else:
            data['reminders'] = {
                "useDefault": False
            }
            if self.reminders:
                data['reminders']["overrides"] = self.reminders

        # Removes all None keys.
        data = {k: v for k, v in data.items() if v is not None}
        # data = json.dumps(data, indent=4, default=str)

        print(data)

        return data

    @staticmethod
    def from_json(json_event: dict):
        start = None
        timezone = None
        start_data = json_event.get('start', None)
        if start_data is not None:
            if 'date' in start_data:
                start = dateutil.parser.parse(start_data['date']).date()
                # start = EventSerializer._get_datetime_from_string(start_data['date']).date()
            else:
                start = dateutil.parser.parse(start_data['dateTime'])
                # start = EventSerializer._get_datetime_from_string(start_data['dateTime'])
            timezone = start_data.get('timeZone', "Africa/Johannesburg")

        end = None
        end_data = json_event.get('end', None)
        if end_data is not None:
            if 'date' in end_data:
                end = dateutil.parser.parse(end_data['date']).date()
                # start = EventSerializer._get_datetime_from_string(start_data['date']).date()
            else:
                end = dateutil.parser.parse(end_data['dateTime'])

        reminders_json = json_event.get('reminders', {})
        reminders = reminders_json.get('overrides', [])

        return CalendarEvent(
            json_event['summary'],
            start=start,
            end=end,
            timezone=timezone,
            event_id=json_event.get('id', None),
            description=json_event.get('description', None),
            location=json_event.get('location', None),
            recurrence=json_event.get('recurrence', None),
            color=json_event.get('colorId', None),
            visibility=json_event.get('visibility', None),
            reminders=reminders,
            default_reminders=reminders_json.get('useDefault', False),
            other=json_event
        )


class Calendar:
    """
    Some calendar functionality.
    inspiration: https://github.com/kuzmoyev/Google-Calendar-Simple-API
    https://developers.google.com/calendar/v3/reference/events/instances

    Possible App Engine implementation:
    https://stackoverflow.com/questions/57764008/using-google-calendar-api-at-an-google-cloud-function
    """

    # If modifying these scopes, delete the file token.pickle.
    # SCOPES = ['https://www.googleapis.com/auth/calendar.readonly']
    SCOPE = ['https://www.googleapis.com/auth/calendar.readonly',
             'https://www.googleapis.com/auth/calendar']

    def __init__(self, method: int = 0):
        """

        :param method: An int of 0 1 or 2 that describes the method to get service.
        Note that method 0 and 1 are best but you cannot change the default reminder when creating events.

        Method 0 and 1 requires you to follow this quick-start:
        Note you must share your calendar to your person email with your service account email.
        Method 2 requires you to follow this quick-start: https://developers.google.com/calendar/quickstart/python
        """
        self.service = None
        self.calendar = Config.calendar_email
        self.get_service(method=method)

    def get_service(self, method: int = 0):
        # for some reason if i put this outside the function and call self.build it throws an error. WTF im gonna cry

        if method == 0:
            # Stolen from Google's client source code from more useful clients
            # https://github.com/googleapis/python-bigquery/blob/master/google/cloud/bigquery/client.py
            # which called the following:
            # https://googleapis.dev/python/google-cloud-core/latest/_modules/google/cloud/client.html#ClientWithProject
            # This just copies from there and it works (this might be the only one that works in the Cloud)
            credentials, _ = google_auth_default()
            credentials = google_auth_credentials.with_scopes_if_required(credentials, self.SCOPE)
            service = build('calendar', 'v3', credentials=credentials)
            self.service = service
        elif method == 1:
            # This would be a desirable outcome since we don't need an extra cred file
            # The following was a suggestion but you need to manually share the calendar with the service account:
            # https://stackoverflow.com/questions/56145686/calendarlist-returns-empty-result-set-with-service-account
            service_acc = os.environ.get('GOOGLE_APPLICATION_CREDENTIALS')
            credentials = service_account.Credentials.from_service_account_file(service_acc, scopes=self.SCOPE)

        else:
            credentials = None
            # The file token.pickle stores the user's access and refresh tokens, and is
            # created automatically when the authorization flow completes for the first
            # time.

            f = FileManager()
            file_name = "token.txt"
            if f.exists(file_name):
                s = f.read(file_name)
                credentials = pickle.loads(codecs.decode(s.encode(), "base64"))

            # If there are no (valid) credentials available, let the user log in.
            if not credentials or not credentials.valid:
                if credentials and credentials.expired and credentials.refresh_token:
                    credentials.refresh(Request())
                else:
                    flow = InstalledAppFlow.from_client_secrets_file(
                        'calendar_credentials.json', self.SCOPE)
                    credentials = flow.run_local_server(port=0)
                # Save the credentials for the next run

                s = codecs.encode(pickle.dumps(credentials), "base64").decode()
                f.write(file_name, s)

        service = build('calendar', 'v3', credentials=credentials)
        self.service = service

    def get_next_n_events(self, n: int) -> list:
        now = datetime.datetime.utcnow().isoformat() + 'Z'  # 'Z' indicates UTC time
        events_result = self.service.events().list(calendarId=self.calendar, timeMin=now,
                                                   maxResults=n, singleEvents=True,
                                                   orderBy='startTime').execute()
        events = events_result.get('items', [])
        events = [CalendarEvent.from_json(event) for event in events]
        return events

    def add_event(self, event: CalendarEvent):
        body = event.to_json()

        event_json = self.service.events().insert(calendarId=self.calendar, body=body).execute()
        return event_json

        # if not events:
        #     print('No upcoming events found.')
        # for event in events:
        #     start = event['start'].get('dateTime', event['start'].get('date'))
        #     print(start, event['summary'])

    def delete_event(self, event: CalendarEvent) -> None:
        """ Deletes an event.
        :param event:
                event object with set event_id.
        """
        if event.event_id is None:
            raise ValueError('Event has to have event_id to be deleted.')
        self.delete_event_by_id(event.event_id)

    def delete_event_by_id(self, event_id: str) -> None:
        """ Deletes an event.
                :param event_id:
                        event string id.
                """
        self.service.events().delete(calendarId=self.calendar, eventId=event_id).execute()

    def list_colors(self) -> None:
        colors = self.service.colors().get().execute()
        # Print available calendarListEntry colors.
        for col_id, color in colors['calendar'].items():
            print('colorId: %s' % col_id)
            print('  Background: %s' % color['background'])
            print('  Foreground: %s' % color['foreground'])
        # Print available event colors.
        for col_id, color in colors['event'].items():
            print('colorId: %s' % col_id)
            print('  Background: %s' % color['background'])
            print('  Foreground: %s' % color['foreground'])

    def list_calendars(self) -> None:
        calendar_list = self.service.calendarList().list().execute()
        for calendar_list_entry in calendar_list['items']:
            print(calendar_list_entry)

    def get_event_by_id(self, event_id: str) -> CalendarEvent:
        event = self.service.events().get(calendarId=self.calendar, eventId=event_id).execute()
        event = CalendarEvent.from_json(event)
        return event

    def get_event_by_name(self, event_summary: str) -> Union[CalendarEvent, None]:
        upcoming_events = self.get_next_n_events(20)
        for event in upcoming_events:
            if event.summary == event_summary:
                return event
        return None


class TextToSpeech:
    """
    Contains some functions for Google's TTS API.
    Can be used within a Google Cloud setting.

    Requirements:

    Cloud usage: requires a service account.

    Native usage: GOOGLE_APPLICATION_CREDENTIALS environment variable which is the path to your .json file.
    """

    def __init__(self):
        self.response = None

    """
    effects profile id
wearable-class-device	Smart watches and other wearables, like Apple Watch, Wear OS watch
handset-class-device	Smartphones, like Google Pixel, Samsung Galaxy, Apple iPhone
headphone-class-device	Earbuds or headphones for audio playback, like Sennheiser headphones
small-bluetooth-speaker-class-device	Small home speakers, like Google Home Mini
medium-bluetooth-speaker-class-device	Smart home speakers, like Google Home
large-home-entertainment-class-device	Home entertainment systems or smart TVs, like Google Home Max, LG TV
large-automotive-class-device	Car speakers
telephony-class-application	Interactive Voice Response (IVR) systems
    """

    def get_text_to_speech(self, message_text: str, speaking_rate=1, pitch=0):
        """
        Connects to Google servers and gets the audio recorded version of the message text.

        :param pitch: Change in pitch of the output voice
        :param speaking_rate: How fast the person speaks between 0.25 and 4
        :param message_text: The text to be converted to speech
        """

        # Instantiates a client
        client = texttospeech.TextToSpeechClient()

        # Set the text input to be synthesized
        synthesis_input = texttospeech.types.SynthesisInput(text=message_text)

        # Build the voice request, select the language code ("en-US") and the ssml
        # voice gender ("neutral")
        # https://cloud.google.com/text-to-speech/docs/voices
        """
        Favourites:
        WaveNet	en-IN	en-IN-Wavenet-C	MALE
        WaveNet	en-GB	en-GB-Wavenet-B	MALE

        WaveNet	en-AU	en-AU-Wavenet-B	MALE
        """
        voice = texttospeech.types.VoiceSelectionParams(
            language_code='en-US',
            name="en-AU-Wavenet-B",
            ssml_gender=texttospeech.enums.SsmlVoiceGender.NEUTRAL)

        # Select the type of audio file you want returned
        audio_config = texttospeech.types.AudioConfig(
            speaking_rate=speaking_rate,
            pitch=pitch,
            audio_encoding=texttospeech.enums.AudioEncoding.MP3)

        # Perform the text-to-speech request on the text input with the selected
        # voice parameters and audio file type
        self.response = client.synthesize_speech(synthesis_input, voice, audio_config)

    def ssml_to_speech(self, ssml):
        """Synthesizes speech from the input string of ssml.

        Note: ssml must be well-formed according to:
            https://www.w3.org/TR/speech-synthesis/

        Example: <speak>Hello there.</speak>
        """
        client = texttospeech.TextToSpeechClient()

        input_text = texttospeech.types.SynthesisInput(ssml=ssml)

        # Note: the voice can also be specified by name.
        # Names of voices can be retrieved with client.list_voices().
        voice = texttospeech.types.VoiceSelectionParams(
            language_code='en-US',
            name='en-US-Standard-C',
            ssml_gender=texttospeech.enums.SsmlVoiceGender.FEMALE)

        audio_config = texttospeech.types.AudioConfig(
            audio_encoding=texttospeech.enums.AudioEncoding.MP3)

        self.response = client.synthesize_speech(input_text, voice, audio_config)

    def save_response_as_mp3(self, mp3_name: str = "output.mp3"):
        """
        Saves the response voice note from Google as an mp3 file.
        Note that get_text_to_speech must have been run before calling this.

        :param mp3_name: The name of the mp3 file to be saved as
        """
        # The response's audio_content is binary.
        with open(mp3_name, 'wb') as out:
            # Write the response to the output file.
            out.write(self.response.audio_content)
            print(f'Audio content written to file "{mp3_name}"')

    @staticmethod
    def list_voices():
        """
        Prints the available voices from Google.
        """
        client = texttospeech.TextToSpeechClient()

        # Performs the list voices request
        voices = client.list_voices()

        for voice in voices.voices:
            # Display the voice's name. Example: tpc-vocoded
            print('Name: {}'.format(voice.name))

            # Display the supported language codes for this voice. Example: "en-US"
            for language_code in voice.language_codes:
                print('Supported language: {}'.format(language_code))

            ssml_gender = enums.SsmlVoiceGender(voice.ssml_gender)

            # Display the SSML Voice Gender
            print('SSML Voice Gender: {}'.format(ssml_gender.name))

            # Display the natural sample rate hertz for this voice. Example: 24000
            print('Natural Sample Rate Hertz: {}\n'.format(
                voice.natural_sample_rate_hertz))


class Vision:
    def __init__(self):
        self.client = vision.ImageAnnotatorClient()

    def get_text(self, bytes_image) -> str:
        image = vision.types.Image(content=bytes_image)
        response = self.client.document_text_detection(image=image)

        result = response.full_text_annotation.text
        return result
